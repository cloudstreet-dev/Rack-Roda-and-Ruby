<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What Rails and Sinatra Are Actually Doing - Rack, Roda, and Ruby</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rails is just a callable. Sinatra is just a callable. So is Roda. This book strips away the magic of Ruby web development, shows you exactly what Rack is doing under the hood, and teaches you to build from first principles. Know your tools. Really know them.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rack, Roda, and Ruby</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby/edit/main/src/what-frameworks-do.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-rails-and-sinatra-are-actually-doing"><a class="header" href="#what-rails-and-sinatra-are-actually-doing">What Rails and Sinatra Are Actually Doing</a></h1>
<p>Now that you know HTTP is text, let's talk about what happens between "the server receives bytes" and "your route handler runs." This is the part that frameworks describe as magic. It isn't.</p>
<h2 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h2>
<p>When an HTTP request hits a Rails or Sinatra application, it passes through several layers before your code sees it:</p>
<ol>
<li>The HTTP server (Puma, WEBrick, Unicorn) accepts a TCP connection and parses raw HTTP text into a structured Ruby hash.</li>
<li>That hash gets passed through Rack middleware — a chain of objects that can inspect, modify, or halt the request before it reaches your application.</li>
<li>Your application receives the (possibly modified) hash, runs your route handler, and returns a status code, headers, and body.</li>
<li>The response travels back up through the middleware chain.</li>
<li>The server serializes the response into HTTP text and writes it to the socket.</li>
</ol>
<p>You control step 3. Rack owns step 2. The server owns steps 1, 4, and 5.</p>
<p>Here's the thing: steps 1 and 3 are what vary between server choices and framework choices. Steps 2 and 4 — the middleware chain — use the same protocol regardless of whether you're using Rails, Sinatra, Roda, or a handwritten Rack app.</p>
<h2 id="lets-look-at-rails"><a class="header" href="#lets-look-at-rails">Let's Look at Rails</a></h2>
<pre><code class="language-ruby"># Gemfile
gem 'rails'

# config.ru (every Rails app has this)
require_relative 'config/environment'
run Rails.application
</code></pre>
<p>That <code>run Rails.application</code> line is the whole story. <code>run</code> is a Rack method that calls your object's <code>call</code> method for every request. <code>Rails.application</code> is a callable.</p>
<p>We can inspect what Rails actually does:</p>
<pre><code class="language-ruby"># In a Rails console
middleware_stack = Rails.application.middleware

middleware_stack.each do |middleware|
  puts middleware.inspect
end
</code></pre>
<p>You'll see something like:</p>
<pre><code>#&lt;ActionDispatch::HostAuthorization ...&gt;
#&lt;Rack::Sendfile ...&gt;
#&lt;ActionDispatch::Static ...&gt;
#&lt;ActionDispatch::Executor ...&gt;
#&lt;ActiveSupport::Cache::Strategy::LocalCache::Middleware ...&gt;
#&lt;Rack::Runtime ...&gt;
#&lt;Rack::MethodOverride ...&gt;
#&lt;ActionDispatch::RequestId ...&gt;
#&lt;ActionDispatch::RemoteIp ...&gt;
#&lt;Sprockets::Rails::QuietAssets ...&gt;
#&lt;Rails::Rack::Logger ...&gt;
#&lt;ActionDispatch::ShowExceptions ...&gt;
#&lt;ActionDispatch::DebugExceptions ...&gt;
#&lt;ActionDispatch::ActionableExceptions ...&gt;
#&lt;ActionDispatch::Reloader ...&gt;
#&lt;ActionDispatch::Callbacks ...&gt;
#&lt;ActiveRecord::Migration::CheckPending ...&gt;
#&lt;ActionDispatch::Cookies ...&gt;
#&lt;ActionDispatch::Session::CookieStore ...&gt;
#&lt;ActionDispatch::Flash ...&gt;
#&lt;ActionDispatch::ContentSecurityPolicy::Middleware ...&gt;
#&lt;ActionDispatch::PermissionsPolicy::Middleware ...&gt;
#&lt;Rack::Head ...&gt;
#&lt;Rack::ConditionalGet ...&gt;
#&lt;Rack::ETag ...&gt;
#&lt;Rack::TempfileReaper ...&gt;
</code></pre>
<p>That's over twenty pieces of middleware wrapping your application before a single request reaches your router. Most of them are doing something useful. <code>Rack::MethodOverride</code> is what makes <code>_method=DELETE</code> in form submissions work. <code>ActionDispatch::Session::CookieStore</code> is where sessions come from. <code>Rack::ETag</code> generates ETags for conditional GET responses.</p>
<p>At the very bottom of that stack is your router, which dispatches to controllers, which call your code. The router is also just a callable.</p>
<h2 id="lets-look-at-sinatra"><a class="header" href="#lets-look-at-sinatra">Let's Look at Sinatra</a></h2>
<p>Sinatra is simpler, which makes it easier to see the structure:</p>
<pre><code class="language-ruby">require 'sinatra/base'

class MyApp &lt; Sinatra::Base
  get '/' do
    'Hello, World!'
  end
end
</code></pre>
<p><code>Sinatra::Base</code> is a Rack application. It has a <code>call</code> method. When you write:</p>
<pre><code class="language-ruby">get '/' do
  'Hello, World!'
end
</code></pre>
<p>...you're adding a route to a routing table that lives inside the <code>call</code> method. The <code>call</code> method looks at the env hash, extracts the HTTP method and path, finds a matching route, and calls your block.</p>
<p>Here's a rough but accurate implementation of what Sinatra's routing core does:</p>
<pre><code class="language-ruby">class TinySinatra
  def initialize
    @routes = {}
  end

  def get(path, &amp;handler)
    @routes[['GET', path]] = handler
  end

  def post(path, &amp;handler)
    @routes[['POST', path]] = handler
  end

  def call(env)
    method = env['REQUEST_METHOD']
    path   = env['PATH_INFO']

    handler = @routes[[method, path]]

    if handler
      body = handler.call
      [200, {'Content-Type' =&gt; 'text/html'}, [body]]
    else
      [404, {'Content-Type' =&gt; 'text/plain'}, ['Not Found']]
    end
  end
end
</code></pre>
<p>That's not a joke. Sinatra's actual implementation is more sophisticated (regex matching, parameter extraction, before/after filters, error handling, template rendering), but the structure is exactly this: a hash of routes, a <code>call</code> method that looks things up in the hash.</p>
<p>Let's verify it works:</p>
<pre><code class="language-ruby">app = TinySinatra.new
app.get('/') { 'Hello!' }
app.get('/about') { 'About page.' }

# Simulate what a Rack server does
env = {
  'REQUEST_METHOD' =&gt; 'GET',
  'PATH_INFO'      =&gt; '/',
  'rack.input'     =&gt; StringIO.new,
}

status, headers, body = app.call(env)
puts status    # 200
puts body      # ["Hello!"]

env['PATH_INFO'] = '/missing'
status, headers, body = app.call(env)
puts status    # 404
</code></pre>
<h2 id="what-frameworks-actually-add"><a class="header" href="#what-frameworks-actually-add">What Frameworks Actually Add</a></h2>
<p>Now we can be precise about what you're paying for when you use a framework:</p>
<p><strong>Rails adds:</strong></p>
<ul>
<li>A routing DSL that handles parameters, constraints, and named routes</li>
<li>Controllers with before/after actions, strong parameters, response helpers</li>
<li>ActiveRecord (this alone is most of the value proposition)</li>
<li>View rendering with template engines and layouts</li>
<li>Asset pipeline</li>
<li>A massive middleware stack with sensible defaults</li>
<li>Conventions that allow code generation and eliminate boilerplate</li>
<li>A very large community and ecosystem</li>
</ul>
<p><strong>Sinatra adds:</strong></p>
<ul>
<li>A routing DSL (simpler than Rails's)</li>
<li>Filters (before/after handlers)</li>
<li>Template rendering</li>
<li>A small, optional middleware stack</li>
<li>Much less convention, more flexibility</li>
</ul>
<p><strong>What neither adds, because Rack already provides it:</strong></p>
<ul>
<li>The protocol for receiving requests and returning responses</li>
<li>The ability to run on any conforming server</li>
<li>The middleware interface</li>
</ul>
<p>This is why you can swap Puma for Unicorn without changing your application. This is why you can write middleware that works in both Rails and Sinatra apps. This is why a Rack app can be embedded inside a Rails app, and a Rails app can be mounted inside a Rack app. They all speak the same protocol.</p>
<h2 id="the-middleware-chain-is-composable"><a class="header" href="#the-middleware-chain-is-composable">The Middleware Chain Is Composable</a></h2>
<p>Here's something you can do in Rails that will make the structure visible:</p>
<pre><code class="language-ruby"># config/application.rb
module MyApp
  class Application &lt; Rails::Application
    # Add our own middleware at the front of the stack
    config.middleware.use LoggingMiddleware

    # Add middleware after a specific existing one
    config.middleware.insert_after ActionDispatch::Flash, CustomMiddleware

    # Remove middleware we don't need
    config.middleware.delete Rack::Runtime
  end
end
</code></pre>
<p>And here's a middleware that you could add to Rails, Sinatra, or a bare Rack app without modification:</p>
<pre><code class="language-ruby">class LoggingMiddleware
  def initialize(app)
    @app = app
  end

  def call(env)
    start = Time.now
    status, headers, body = @app.call(env)
    elapsed = Time.now - start

    puts "[#{status}] #{env['REQUEST_METHOD']} #{env['PATH_INFO']} (#{elapsed.round(4)}s)"

    [status, headers, body]
  end
end
</code></pre>
<p>This is not framework-specific code. It's Rack code. It works because both Rails and Sinatra are Rack applications, and this is a Rack middleware.</p>
<h2 id="the-call-stack"><a class="header" href="#the-call-stack">The Call Stack</a></h2>
<p>When a request comes in, execution looks like this:</p>
<pre><code>Server.call(env)
  LoggingMiddleware.call(env)
    Rack::Session::Cookie.call(env)
      Rack::MethodOverride.call(env)
        YourApplication.call(env)
          # Your route runs here
          # Returns [200, headers, body]
        # MethodOverride gets [200, headers, body]
      # Session middleware gets [200, headers, body]
    # Logging middleware gets [200, headers, body]
  # Server sends the response
</code></pre>
<p>Each layer wraps the next. Each layer can modify the request env before passing it down, and modify the response before passing it up. The pattern is: wrap the inner app, call it, do something with the result.</p>
<p>This is just function composition, with objects instead of functions. If you've worked with function pipelines in Elixir or middleware in Express.js, it's the same idea.</p>
<h2 id="why-this-matters-for-you"><a class="header" href="#why-this-matters-for-you">Why This Matters for You</a></h2>
<p>When something goes wrong in a web application, it happens at one of these layers:</p>
<ul>
<li>The server layer: connection issues, SSL errors, timeout behavior</li>
<li>The middleware layer: session corruption, cookie issues, CSRF failures, content encoding problems</li>
<li>The routing layer: 404s, parameter parsing, path matching</li>
<li>The application layer: your actual code</li>
</ul>
<p>When you don't know these layers exist, every bug is mysterious. When you do, you can narrow it down quickly. Is the bug in your code, or is it in the middleware below your code? Add a middleware that logs the env before your code runs. Is the response wrong, or is a middleware above you rewriting it? Log the response after your code runs.</p>
<p>The tools for this kind of debugging are available to you the moment you understand that your application is wrapped in a stack of callables.</p>
<p>That's what frameworks are doing. They're arranging callables in a useful order and providing defaults that most applications need. The next step is to look at the protocol that makes all of this possible.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="http-is-just-text.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="rack/the-spec.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="http-is-just-text.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="rack/the-spec.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
