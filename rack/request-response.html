<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Request and Response Objects (DIY Edition) - Rack, Roda, and Ruby</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rails is just a callable. Sinatra is just a callable. So is Roda. This book strips away the magic of Ruby web development, shows you exactly what Rack is doing under the hood, and teaches you to build from first principles. Know your tools. Really know them.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rack, Roda, and Ruby</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby/edit/main/src/rack/request-response.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="request-and-response-objects-diy-edition"><a class="header" href="#request-and-response-objects-diy-edition">Request and Response Objects (DIY Edition)</a></h1>
<p>By now you've been reading <code>env['REQUEST_METHOD']</code> and returning <code>[200, headers, body]</code> directly. This works, but it's verbose. Real applications build thin wrapper objects around the raw data structures to make the common cases easier.</p>
<p>The <code>rack</code> gem ships with <code>Rack::Request</code> and <code>Rack::Response</code>. They're good. But let's build our own versions first, so we understand what they're doing and why.</p>
<h2 id="the-problem-with-raw-env"><a class="header" href="#the-problem-with-raw-env">The Problem with Raw Env</a></h2>
<p>Accessing request data from the raw env hash has a few annoyances:</p>
<pre><code class="language-ruby"># Reading headers is inconsistent
host         = env['HTTP_HOST']            # most headers
content_type = env['CONTENT_TYPE']        # except Content-Type
content_len  = env['CONTENT_LENGTH']      # and Content-Length

# Checking HTTP method
is_get  = env['REQUEST_METHOD'] == 'GET'
is_post = env['REQUEST_METHOD'] == 'POST'

# Reading the body (destructive! can only read once)
body = env['rack.input'].read

# Parsing query string
require 'uri'
params = URI.decode_www_form(env['QUERY_STRING']).to_h

# Getting the full URL
scheme = env['rack.url_scheme']
host   = env['HTTP_HOST']
path   = env['PATH_INFO']
qs     = env['QUERY_STRING']
url    = "#{scheme}://#{host}#{path}"
url   += "?#{qs}" unless qs.empty?
</code></pre>
<p>None of this is wrong, but it's tedious. A request object wraps these lookups in named methods.</p>
<h2 id="building-a-request-wrapper"><a class="header" href="#building-a-request-wrapper">Building a Request Wrapper</a></h2>
<pre><code class="language-ruby">class Request
  attr_reader :env

  def initialize(env)
    @env = env
  end

  # HTTP method
  def request_method = env['REQUEST_METHOD']
  def get?    = request_method == 'GET'
  def post?   = request_method == 'POST'
  def put?    = request_method == 'PUT'
  def patch?  = request_method == 'PATCH'
  def delete? = request_method == 'DELETE'
  def head?   = request_method == 'HEAD'

  # Path and query
  def path         = env['PATH_INFO']
  def query_string = env['QUERY_STRING']
  def script_name  = env['SCRIPT_NAME']
  def full_path    = query_string.empty? ? path : "#{path}?#{query_string}"

  # URL construction
  def scheme = env['rack.url_scheme'] || 'http'
  def host   = env['HTTP_HOST'] || env['SERVER_NAME']
  def port   = env['SERVER_PORT']
  def url    = "#{scheme}://#{host}#{full_path}"

  # Headers (Rack-normalized: HTTP_ACCEPT -&gt; Accept)
  def headers
    @headers ||= env.each_with_object({}) do |(key, value), h|
      if key.start_with?('HTTP_')
        name = key.sub('HTTP_', '').split('_').map(&amp;:capitalize).join('-')
        h[name] = value
      elsif key == 'CONTENT_TYPE'
        h['Content-Type'] = value
      elsif key == 'CONTENT_LENGTH'
        h['Content-Length'] = value
      end
    end
  end

  def content_type   = env['CONTENT_TYPE']
  def content_length = env['CONTENT_LENGTH']&amp;.to_i

  # Individual header lookup — normalizes to Rack format
  def [](header_name)
    key = "HTTP_#{header_name.upcase.tr('-', '_')}"
    env[key] || env[header_name.upcase.tr('-', '_')]
  end

  # Query parameters (parsed and decoded)
  def query_params
    @query_params ||= parse_query(query_string)
  end

  # POST body params (for application/x-www-form-urlencoded)
  def post_params
    @post_params ||= if content_type&amp;.include?('application/x-www-form-urlencoded')
      parse_query(body_string)
    else
      {}
    end
  end

  # Merged params: query + post body (query takes precedence on collision)
  def params
    @params ||= post_params.merge(query_params)
  end

  # Raw body (reads once, then cached)
  def body
    env['rack.input']
  end

  def body_string
    @body_string ||= begin
      body.rewind  # reset in case it was partially read
      body.read
    end
  end

  # JSON body parsing
  def json
    @json ||= if content_type&amp;.include?('application/json')
      require 'json'
      JSON.parse(body_string)
    end
  end

  # Cookies
  def cookies
    @cookies ||= parse_cookies(env['HTTP_COOKIE'] || '')
  end

  # IP address (respects X-Forwarded-For if behind a proxy)
  def ip
    env['HTTP_X_FORWARDED_FOR']&amp;.split(',')&amp;.first&amp;.strip ||
      env['REMOTE_ADDR']
  end

  # Is this an AJAX request?
  def xhr?
    env['HTTP_X_REQUESTED_WITH']&amp;.downcase == 'xmlhttprequest'
  end

  # What content types does the client accept?
  def accepts?(mime_type)
    accept = env['HTTP_ACCEPT'] || '*/*'
    accept.include?(mime_type) || accept.include?('*/*')
  end

  private

  def parse_query(string)
    return {} if string.nil? || string.empty?
    require 'uri'
    URI.decode_www_form(string).each_with_object({}) do |(k, v), h|
      if h.key?(k)
        h[k] = Array(h[k]) &lt;&lt; v
      else
        h[k] = v
      end
    end
  end

  def parse_cookies(string)
    string.split('; ').each_with_object({}) do |pair, h|
      name, value = pair.split('=', 2)
      h[name] = value if name
    end
  end
end
</code></pre>
<h2 id="building-a-response-helper"><a class="header" href="#building-a-response-helper">Building a Response Helper</a></h2>
<p>The response is <code>[status, headers, body]</code>. Building it manually is fine for simple cases but gets tedious when you're setting multiple headers or building the body incrementally.</p>
<pre><code class="language-ruby">class Response
  attr_accessor :status
  attr_reader :headers

  def initialize(status = 200, headers = {})
    @status  = status
    @headers = {'Content-Type' =&gt; 'text/html; charset=utf-8'}.merge(headers)
    @body    = []
    @finished = false
  end

  # Write to the body buffer
  def write(str)
    raise 'Response already finished' if @finished
    @body &lt;&lt; str.to_s
    self
  end

  def &lt;&lt;(str) = write(str)

  # Set a header
  def []=(name, value)
    @headers[name] = value
  end

  def [](name)
    @headers[name]
  end

  # Common response types
  def set_cookie(name, value, options = {})
    cookie = "#{name}=#{value}"
    cookie += "; Path=#{options[:path] || '/'}"
    cookie += "; HttpOnly" if options[:http_only] != false
    cookie += "; Secure"   if options[:secure]
    cookie += "; SameSite=#{options[:same_site]}" if options[:same_site]
    if options[:expires]
      cookie += "; Expires=#{options[:expires].httpdate}"
    end
    # Multiple Set-Cookie headers need to be handled carefully
    existing = @headers['Set-Cookie']
    @headers['Set-Cookie'] = existing ? "#{existing}\n#{cookie}" : cookie
  end

  def delete_cookie(name)
    set_cookie(name, '', expires: Time.at(0))
  end

  # Redirect helpers
  def redirect(location, status = 302)
    @status = status
    @headers['Location'] = location
    @body = []
    self
  end

  # Finish: set Content-Length and return the Rack triple
  def finish
    @finished = true
    body = @body

    unless @headers['Content-Length']
      size = body.sum(&amp;:bytesize)
      @headers['Content-Length'] = size.to_s
    end

    [@status, @headers, body]
  end

  # Convenience: finish with a body written all at once
  def self.text(body, status: 200)
    r = new(status, 'Content-Type' =&gt; 'text/plain')
    r.write(body)
    r.finish
  end

  def self.html(body, status: 200)
    r = new(status, 'Content-Type' =&gt; 'text/html; charset=utf-8')
    r.write(body)
    r.finish
  end

  def self.json(data, status: 200)
    require 'json'
    body = JSON.generate(data)
    r = new(status, 'Content-Type' =&gt; 'application/json')
    r.write(body)
    r.finish
  end

  def self.redirect(location, status: 302)
    r = new(status)
    r.redirect(location, status)
    r.finish
  end
end
</code></pre>
<h2 id="using-them-together"><a class="header" href="#using-them-together">Using Them Together</a></h2>
<p>Here's our NotesApp rewritten with these helpers:</p>
<pre><code class="language-ruby">require_relative 'request'
require_relative 'response'
require 'json'

class NotesApp
  def initialize
    @notes  = {}
    @next_id = 1
  end

  def call(env)
    req = Request.new(env)

    case [req.request_method, req.path]
    when ['GET', '/notes']
      Response.json(@notes.values)

    when ['POST', '/notes']
      create_note(req)

    else
      if (match = req.path.match(%r{\A/notes/(\d+)\z}))
        id = match[1].to_i
        case req.request_method
        when 'GET'    then show_note(id)
        when 'DELETE' then delete_note(id)
        else Response.json({'error' =&gt; 'Method not allowed'}, status: 405)
        end
      else
        Response.json({'error' =&gt; 'Not found'}, status: 404)
      end
    end
  end

  private

  def show_note(id)
    note = @notes[id]
    return Response.json({'error' =&gt; 'Not found'}, status: 404) unless note
    Response.json(note)
  end

  def create_note(req)
    data = req.json
    return Response.json({'error' =&gt; 'Invalid JSON'}, status: 400) unless data

    note = {
      'id'      =&gt; @next_id,
      'content' =&gt; data['content'].to_s,
      'created' =&gt; Time.now.iso8601,
    }
    @notes[@next_id] = note
    @next_id += 1

    Response.json(note, status: 201)
  rescue JSON::ParserError
    Response.json({'error' =&gt; 'Invalid JSON'}, status: 400)
  end

  def delete_note(id)
    return Response.json({'error' =&gt; 'Not found'}, status: 404) unless @notes.key?(id)
    @notes.delete(id)
    [204, {}, []]
  end
end
</code></pre>
<p>Cleaner. <code>req.json</code> instead of <code>JSON.parse(env['rack.input'].read)</code>. <code>Response.json(data)</code> instead of the three-line array construction.</p>
<h2 id="racks-built-in-versions"><a class="header" href="#racks-built-in-versions">Rack's Built-in Versions</a></h2>
<p><code>Rack::Request</code> and <code>Rack::Response</code> do everything above, plus:</p>
<ul>
<li><code>Rack::Request#params</code> handles multipart form data (file uploads)</li>
<li><code>Rack::Request#session</code> accesses the session (set by session middleware)</li>
<li><code>Rack::Response</code> handles <code>Transfer-Encoding: chunked</code> for streaming</li>
<li>Both handle edge cases in encoding and parsing that our implementations skip</li>
</ul>
<p>There's no reason to use our versions in production. But now you know what they are: thin wrappers that make the env hash and response array more ergonomic. Not magic. Not framework infrastructure. Just Ruby objects.</p>
<h2 id="the-body-is-lazy"><a class="header" href="#the-body-is-lazy">The Body Is Lazy</a></h2>
<p>One important detail about the response body: it's supposed to be lazy. The Rack spec says the body responds to <code>each</code>, and the server calls <code>each</code> to get the chunks. It doesn't have to be an Array.</p>
<p>This means you can stream large responses without loading everything into memory:</p>
<pre><code class="language-ruby">class FileStreamer
  def initialize(path)
    @path = path
  end

  def each
    File.open(@path, 'rb') do |file|
      while (chunk = file.read(16_384))  # read 16KB at a time
        yield chunk
      end
    end
  end

  def close
    # nothing to close — File.open handles it
  end
end

# In a Rack app:
def call(env)
  [
    200,
    {
      'Content-Type'        =&gt; 'application/octet-stream',
      'Content-Disposition' =&gt; 'attachment; filename="large_file.bin"',
    },
    FileStreamer.new('/path/to/large_file.bin')
  ]
end
</code></pre>
<p>The server calls <code>.each</code> on the body, yields chunks to the client as they're read, and memory usage stays flat even for multi-gigabyte files. <code>Rack::Sendfile</code> takes this further — if the server supports it, you tell the server the file path and the server handles the streaming at the OS level, bypassing Ruby entirely.</p>
<h2 id="the-insight"><a class="header" href="#the-insight">The Insight</a></h2>
<p>Request and response objects are not architecture — they're ergonomics. The underlying data structures are still a hash and an array. The wrappers exist so you don't have to remember that <code>Content-Type</code> uses a different env key format than other headers, or that the body needs <code>Content-Length</code> set, or that <code>rack.input</code> might need to be rewound before reading.</p>
<p>When <code>Rack::Request</code> or <code>Rack::Response</code> does something unexpected, you can read its source. It's a short file. It's doing exactly what we just did.</p>
<p>This concludes the Rack section. You've seen the spec, built apps against it, written a server, implemented middleware, built a router, and wrapped the env in ergonomic objects. You know what's happening.</p>
<p>Next: why Rack alone still isn't quite enough for most applications.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rack/routing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../roda/why-rack-alone-isnt-enough.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rack/routing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../roda/why-rack-alone-isnt-enough.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
