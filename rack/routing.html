<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Routing Without a Framework (It&#x27;s Just String Matching) - Rack, Roda, and Ruby</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rails is just a callable. Sinatra is just a callable. So is Roda. This book strips away the magic of Ruby web development, shows you exactly what Rack is doing under the hood, and teaches you to build from first principles. Know your tools. Really know them.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rack, Roda, and Ruby</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby/edit/main/src/rack/routing.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="routing-without-a-framework-its-just-string-matching"><a class="header" href="#routing-without-a-framework-its-just-string-matching">Routing Without a Framework (It's Just String Matching)</a></h1>
<p>Routing is the process of mapping an incoming HTTP request to a handler. Frameworks make this look sophisticated. It isn't. It's string matching with some parameter extraction.</p>
<p>Let's implement a router from scratch, then look at what frameworks add on top.</p>
<h2 id="what-routing-actually-is"><a class="header" href="#what-routing-actually-is">What Routing Actually Is</a></h2>
<p>Given a request with <code>METHOD = "GET"</code> and <code>PATH_INFO = "/users/42/posts"</code>, routing finds the code that should handle it. The two inputs are the HTTP method and the path. The outputs are: either "run this code" or "404."</p>
<p>That's the whole problem. Everything else is ergonomics.</p>
<h2 id="the-simplest-router"><a class="header" href="#the-simplest-router">The Simplest Router</a></h2>
<p>From the previous chapter's NotesApp, we had:</p>
<pre><code class="language-ruby">case [method, path]
when ['GET', '/notes']
  list_notes
when ['POST', '/notes']
  create_note(env)
end
</code></pre>
<p>This is a router. It matches on method and exact path. The problem: it doesn't handle path parameters (<code>/notes/42</code>).</p>
<h2 id="path-parameters-via-regex"><a class="header" href="#path-parameters-via-regex">Path Parameters via Regex</a></h2>
<pre><code class="language-ruby">class Router
  def initialize
    @routes = []
  end

  def add(method, pattern, &amp;handler)
    # Convert /users/:id/posts to a regex with named captures
    regex = pattern.gsub(/:(\w+)/, '(?&lt;\1&gt;[^/]+)')
    regex = Regexp.new("\\A#{regex}\\z")
    @routes &lt;&lt; {method: method, pattern: regex, handler: handler}
  end

  def get(path, &amp;block)  = add('GET',    path, &amp;block)
  def post(path, &amp;block) = add('POST',   path, &amp;block)
  def put(path, &amp;block)  = add('PUT',    path, &amp;block)
  def patch(path, &amp;block)= add('PATCH',  path, &amp;block)
  def delete(path, &amp;block)=add('DELETE', path, &amp;block)

  def call(env)
    method = env['REQUEST_METHOD']
    path   = env['PATH_INFO']

    @routes.each do |route|
      next unless route[:method] == method
      next unless (match = route[:pattern].match(path))

      # Extract named captures as string keys
      params = match.named_captures
      env['router.params'] = params

      return route[:handler].call(env, params)
    end

    [404, {'Content-Type' =&gt; 'text/plain'}, ['Not Found']]
  end
end
</code></pre>
<p>Using it:</p>
<pre><code class="language-ruby">router = Router.new

router.get('/') do |env, params|
  [200, {'Content-Type' =&gt; 'text/plain'}, ['Welcome']]
end

router.get('/users/:id') do |env, params|
  [200, {'Content-Type' =&gt; 'text/plain'}, ["User #{params['id']}"]]
end

router.get('/users/:user_id/posts/:id') do |env, params|
  body = "Post #{params['id']} by user #{params['user_id']}"
  [200, {'Content-Type' =&gt; 'text/plain'}, [body]]
end

router.post('/users') do |env, params|
  # Create a user...
  [201, {'Content-Type' =&gt; 'text/plain'}, ['Created']]
end
</code></pre>
<p>Test it:</p>
<pre><code class="language-ruby">require 'rack/mock'

def request(router, method, path)
  env = Rack::MockRequest.env_for(path, method: method)
  status, _, body = router.call(env)
  [status, body.join]
end

puts request(router, 'GET',  '/')                          # [200, "Welcome"]
puts request(router, 'GET',  '/users/42')                  # [200, "User 42"]
puts request(router, 'GET',  '/users/42/posts/7')          # [200, "Post 7 by user 42"]
puts request(router, 'POST', '/users')                     # [201, "Created"]
puts request(router, 'GET',  '/nonexistent')               # [404, "Not Found"]
</code></pre>
<h2 id="the-regex-trick"><a class="header" href="#the-regex-trick">The Regex Trick</a></h2>
<p>The pattern translation deserves a closer look:</p>
<pre><code class="language-ruby">pattern = '/users/:id/posts/:post_id'

# Step 1: Replace :param with a named capture group
regex_str = pattern.gsub(/:(\w+)/, '(?&lt;\1&gt;[^/]+)')
# =&gt; "/users/(?&lt;id&gt;[^/]+)/posts/(?&lt;post_id&gt;[^/]+)"

# Step 2: Anchor it
regex = Regexp.new("\\A#{regex_str}\\z")
# =&gt; /\A\/users\/(?&lt;id&gt;[^\/]+)\/posts\/(?&lt;post_id&gt;[^\/]+)\z/

# Test it
match = regex.match('/users/42/posts/7')
match.named_captures   # =&gt; {"id"=&gt;"42", "post_id"=&gt;"7"}
</code></pre>
<p><code>[^/]+</code> matches one or more characters that aren't a slash — which is what a URL segment is. Named captures (the <code>?&lt;name&gt;</code> syntax) let us extract those values by name.</p>
<p>This is what every Ruby routing library does underneath. Some add wildcard matching (<code>*path</code>), optional segments (<code>(/edit)?</code>), or format matching (<code>.json</code>). The core is always the same regex transform.</p>
<h2 id="constraint-based-routing"><a class="header" href="#constraint-based-routing">Constraint-Based Routing</a></h2>
<p>Rails routes support constraints like <code>id: /\d+/</code>. We can add that:</p>
<pre><code class="language-ruby">def add(method, pattern, constraints: {}, &amp;handler)
  # Build base regex, replacing :param with a named capture
  regex_str = pattern.gsub(/:(\w+)/) do |match|
    param_name = $1
    # Use constraint regex if provided, otherwise match any non-slash chars
    param_pattern = constraints[param_name.to_sym]&amp;.source || '[^/]+'
    "(?&lt;#{param_name}&gt;#{param_pattern})"
  end

  regex = Regexp.new("\\A#{regex_str}\\z")
  @routes &lt;&lt; {method: method, pattern: regex, handler: handler}
end

# Usage: only match numeric IDs
router.get('/users/:id', constraints: {id: /\d+/}) do |env, params|
  [200, {}, ["User #{params['id']}"]]
end

# This matches:   GET /users/42
# This doesn't:   GET /users/alice
</code></pre>
<h2 id="mounting-rack-apps-at-paths"><a class="header" href="#mounting-rack-apps-at-paths">Mounting Rack Apps at Paths</a></h2>
<p>Routing isn't just about handlers — you can route to entire Rack applications:</p>
<pre><code class="language-ruby">class PathRouter
  def initialize
    @mounts = []
    @routes = []
  end

  def mount(path, app)
    @mounts &lt;&lt; {prefix: path, app: app}
  end

  def call(env)
    path = env['PATH_INFO']

    # Check mounts first — rewrite PATH_INFO for the mounted app
    @mounts.each do |mount|
      if path.start_with?(mount[:prefix])
        env = env.merge(
          'SCRIPT_NAME' =&gt; env['SCRIPT_NAME'] + mount[:prefix],
          'PATH_INFO'   =&gt; path.sub(mount[:prefix], '') || '/',
        )
        return mount[:app].call(env)
      end
    end

    # Then check plain routes
    # ... (same as before)
    
    [404, {'Content-Type' =&gt; 'text/plain'}, ['Not Found']]
  end
end

# Example:
router = PathRouter.new
router.mount('/api/v1', ApiApp.new)
router.mount('/admin', AdminApp.new)
</code></pre>
<p>This is exactly how Rails's <code>mount</code> directive works. <code>SCRIPT_NAME</code> tracks how much of the path has been consumed by the routing layer, and <code>PATH_INFO</code> contains the remaining path for the mounted app to interpret.</p>
<h2 id="a-full-featured-example"><a class="header" href="#a-full-featured-example">A Full-Featured Example</a></h2>
<p>Let's build a complete router that a small real application could actually use:</p>
<pre><code class="language-ruby"># router.rb
class Router
  Route = Struct.new(:method, :pattern, :named_params, :handler)

  def initialize
    @routes = []
    @not_found = method(:default_not_found)
    @error     = method(:default_error)
  end

  def get(path, &amp;block)    = define('GET',    path, &amp;block)
  def post(path, &amp;block)   = define('POST',   path, &amp;block)
  def put(path, &amp;block)    = define('PUT',    path, &amp;block)
  def patch(path, &amp;block)  = define('PATCH',  path, &amp;block)
  def delete(path, &amp;block) = define('DELETE', path, &amp;block)
  def head(path, &amp;block)   = define('HEAD',   path, &amp;block)

  def not_found(&amp;block) = (@not_found = block)
  def error(&amp;block)     = (@error     = block)

  def call(env)
    method = env['REQUEST_METHOD']
    path   = env['PATH_INFO'].chomp('/')
    path   = '/' if path.empty?

    @routes.each do |route|
      next unless route.method == method || (method == 'HEAD' &amp;&amp; route.method == 'GET')

      if (match = route.pattern.match(path))
        params = match.named_captures
        env['router.params'] = params
        return route.handler.call(env, params)
      end
    end

    @not_found.call(env)
  rescue StandardError =&gt; e
    @error.call(env, e)
  end

  private

  def define(method, path, &amp;handler)
    named_params = path.scan(/:(\w+)/).flatten
    pattern_str  = path.gsub(/:(\w+)/, '(?&lt;\1&gt;[^/]+)')
    pattern      = Regexp.new("\\A#{pattern_str}\\z")
    @routes &lt;&lt; Route.new(method, pattern, named_params, handler)
  end

  def default_not_found(env)
    [404, {'Content-Type' =&gt; 'text/plain'}, ['Not Found']]
  end

  def default_error(env, exception)
    $stderr.puts "#{exception.class}: #{exception.message}"
    $stderr.puts exception.backtrace.first(10).join("\n")
    [500, {'Content-Type' =&gt; 'text/plain'}, ['Internal Server Error']]
  end
end
</code></pre>
<p>Use it as a Rack app:</p>
<pre><code class="language-ruby"># config.ru
require_relative 'router'
require_relative 'handlers'  # wherever your handler code lives

router = Router.new

router.get('/') do |env, params|
  [200, {'Content-Type' =&gt; 'text/html'}, ['&lt;h1&gt;Home&lt;/h1&gt;']]
end

router.get('/users/:id') do |env, params|
  user = User.find(params['id'].to_i)
  [200, {'Content-Type' =&gt; 'application/json'}, [user.to_json]]
end

router.not_found do |env|
  [404, {'Content-Type' =&gt; 'text/html'}, ['&lt;h1&gt;Page Not Found&lt;/h1&gt;']]
end

run router
</code></pre>
<h2 id="what-frameworks-add-on-top"><a class="header" href="#what-frameworks-add-on-top">What Frameworks Add on Top</a></h2>
<p>Our router covers the basics. Here's what Rails's and Sinatra's routers add:</p>
<p><strong>Named routes and URL helpers</strong>: <code>user_path(id: 42)</code> instead of <code>"/users/#{42}"</code>. This requires storing route patterns as templates, not just regexes.</p>
<p><strong>Nested resources</strong>: <code>resources :users do; resources :posts; end</code> generates all CRUD routes for posts nested under users. Our router requires you to define each route manually.</p>
<p><strong>Route priorities and overrides</strong>: When multiple routes could match, Rails has a precise priority order. Our router uses first-match-wins, which is simpler but less flexible.</p>
<p><strong>Format matching</strong>: Rails can route <code>GET /users/42.json</code> differently from <code>GET /users/42</code>, based on the format suffix or <code>Accept</code> header.</p>
<p><strong>Redirect and inline responders</strong>: <code>get '/old', redirect('/new')</code> in Sinatra.</p>
<p><strong>Route constraints with arbitrary code</strong>: Rails lets you pass lambdas as constraints.</p>
<p>These are real features that real applications use. They're also each independently implementable on top of what we've built — the router isn't magical, it's just accreted features.</p>
<h2 id="the-insight"><a class="header" href="#the-insight">The Insight</a></h2>
<p>A router is a list of <code>(method, pattern, handler)</code> tuples. Matching is: iterate the list, test each pattern against the incoming path, run the first match. Everything else is optimization or ergonomics.</p>
<p>When you see a routing DSL — <code>resources :users</code>, <code>namespace :api</code>, <code>scope '/v2'</code> — it's generating these tuples. The DSL exists because writing tuples manually is tedious at scale. But it's still tuples.</p>
<p>If you ever need to debug a routing issue, you can inspect the generated routes. In Rails: <code>Rails.application.routes.routes</code> gives you the raw route list. In Sinatra: <code>MyApp.routes</code> shows all defined routes. You're looking at the tuples.</p>
<p>Next: making request and response handling a little less manual.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rack/middleware.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rack/request-response.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rack/middleware.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rack/request-response.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
