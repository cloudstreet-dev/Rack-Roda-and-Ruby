<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Build a Rack Server from Scratch - Rack, Roda, and Ruby</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rails is just a callable. Sinatra is just a callable. So is Roda. This book strips away the magic of Ruby web development, shows you exactly what Rack is doing under the hood, and teaches you to build from first principles. Know your tools. Really know them.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rack, Roda, and Ruby</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby/edit/main/src/rack/server-from-scratch.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="build-a-rack-server-from-scratch"><a class="header" href="#build-a-rack-server-from-scratch">Build a Rack Server from Scratch</a></h1>
<p>A Rack server has one job: accept HTTP connections, parse them into a Rack env hash, call your application, and serialize the response back into HTTP. Let's build one.</p>
<p>This isn't a production server. It handles one request at a time, ignores keep-alive, has no TLS, and will fall over under load. It is, however, a real HTTP server that speaks valid HTTP/1.1 and can run actual Rack applications. Understanding it will demystify everything that happens before your application code runs.</p>
<h2 id="the-structure"><a class="header" href="#the-structure">The Structure</a></h2>
<p>A Rack server needs to:</p>
<ol>
<li>Listen on a TCP port</li>
<li>Accept connections in a loop</li>
<li>Parse the HTTP request into a Rack env hash</li>
<li>Call the application with the env</li>
<li>Serialize the <code>[status, headers, body]</code> response into HTTP</li>
<li>Write it to the socket</li>
</ol>
<p>Let's build each piece.</p>
<h2 id="step-1-the-tcp-listener"><a class="header" href="#step-1-the-tcp-listener">Step 1: The TCP Listener</a></h2>
<pre><code class="language-ruby">require 'socket'

server = TCPServer.new('0.0.0.0', 9292)
puts "Listening on http://localhost:9292"

loop do
  client = server.accept
  # handle client
  client.close
end
</code></pre>
<p><code>TCPServer.new</code> opens a socket. <code>server.accept</code> blocks until a connection arrives, then returns a <code>TCPSocket</code> representing that connection. Straightforward.</p>
<h2 id="step-2-parsing-the-http-request"><a class="header" href="#step-2-parsing-the-http-request">Step 2: Parsing the HTTP Request</a></h2>
<p>HTTP requests look like this:</p>
<pre><code>GET /path?query=string HTTP/1.1\r\n
Host: localhost:9292\r\n
Accept: text/html\r\n
\r\n
</code></pre>
<p>We need to parse this into a Rack env hash. The tricky parts are:</p>
<ul>
<li>Headers end at a blank line (<code>\r\n</code> alone)</li>
<li>The body follows the blank line, if <code>Content-Length</code> is set</li>
<li>Header names become <code>HTTP_UPPERCASED_WITH_UNDERSCORES</code></li>
</ul>
<pre><code class="language-ruby">def parse_request(client)
  # Read the request line
  request_line = client.gets&amp;.chomp
  return nil unless request_line

  method, full_path, http_version = request_line.split(' ', 3)
  path, query_string = full_path.split('?', 2)

  # Read headers until blank line
  headers = {}
  while (line = client.gets&amp;.chomp) &amp;&amp; !line.empty?
    name, value = line.split(': ', 2)
    headers[name] = value
  end

  # Read body if Content-Length is present
  body = ''
  if (length = headers['Content-Length']&amp;.to_i) &amp;&amp; length &gt; 0
    body = client.read(length)
  end

  # Build the Rack env
  env = {
    # Required CGI variables
    'REQUEST_METHOD'    =&gt; method,
    'SCRIPT_NAME'       =&gt; '',
    'PATH_INFO'         =&gt; path,
    'QUERY_STRING'      =&gt; query_string || '',
    'SERVER_NAME'       =&gt; 'localhost',
    'SERVER_PORT'       =&gt; '9292',
    'HTTP_VERSION'      =&gt; http_version,
    'SERVER_PROTOCOL'   =&gt; http_version,

    # Rack-specific
    'rack.version'      =&gt; [1, 3],
    'rack.input'        =&gt; StringIO.new(body),
    'rack.errors'       =&gt; $stderr,
    'rack.multithread'  =&gt; false,
    'rack.multiprocess' =&gt; false,
    'rack.run_once'     =&gt; false,
    'rack.url_scheme'   =&gt; 'http',
  }

  # Convert HTTP headers to CGI format
  headers.each do |name, value|
    # Content-Type and Content-Length get special treatment
    key = case name
          when 'Content-Type'   then 'CONTENT_TYPE'
          when 'Content-Length' then 'CONTENT_LENGTH'
          else "HTTP_#{name.upcase.gsub('-', '_')}"
          end
    env[key] = value
  end

  env
end
</code></pre>
<p>The header name transformation — <code>Content-Type</code> becomes <code>HTTP_CONTENT_TYPE</code>, <code>X-Request-Id</code> becomes <code>HTTP_X_REQUEST_ID</code> — is a CGI convention that Rack inherits. It's annoying but consistent.</p>
<h2 id="step-3-serializing-the-response"><a class="header" href="#step-3-serializing-the-response">Step 3: Serializing the Response</a></h2>
<p>The response is <code>[status, headers, body]</code>. We need to turn that into HTTP/1.1 text:</p>
<pre><code class="language-ruby">STATUS_PHRASES = {
  200 =&gt; 'OK',
  201 =&gt; 'Created',
  204 =&gt; 'No Content',
  301 =&gt; 'Moved Permanently',
  302 =&gt; 'Found',
  304 =&gt; 'Not Modified',
  400 =&gt; 'Bad Request',
  401 =&gt; 'Unauthorized',
  403 =&gt; 'Forbidden',
  404 =&gt; 'Not Found',
  405 =&gt; 'Method Not Allowed',
  415 =&gt; 'Unsupported Media Type',
  422 =&gt; 'Unprocessable Entity',
  500 =&gt; 'Internal Server Error',
}.freeze

def send_response(client, status, headers, body)
  phrase = STATUS_PHRASES[status] || 'Unknown'

  # Status line
  client.write("HTTP/1.1 #{status} #{phrase}\r\n")

  # Headers
  headers.each do |name, value|
    client.write("#{name}: #{value}\r\n")
  end

  # Blank line separating headers from body
  client.write("\r\n")

  # Body — iterate over whatever the app gave us
  body.each do |chunk|
    client.write(chunk)
  end

  # Some body objects need to be closed (file handles, etc.)
  body.close if body.respond_to?(:close)
end
</code></pre>
<h2 id="putting-it-together"><a class="header" href="#putting-it-together">Putting It Together</a></h2>
<pre><code class="language-ruby"># tiny_server.rb
require 'socket'
require 'stringio'

STATUS_PHRASES = {
  200 =&gt; 'OK', 201 =&gt; 'Created', 204 =&gt; 'No Content',
  301 =&gt; 'Moved Permanently', 302 =&gt; 'Found',
  400 =&gt; 'Bad Request', 401 =&gt; 'Unauthorized',
  403 =&gt; 'Forbidden', 404 =&gt; 'Not Found',
  405 =&gt; 'Method Not Allowed', 500 =&gt; 'Internal Server Error',
}.freeze

def parse_request(client)
  request_line = client.gets&amp;.chomp
  return nil unless request_line &amp;&amp; !request_line.empty?

  method, full_path, http_version = request_line.split(' ', 3)
  path, query_string = full_path.split('?', 2)

  headers = {}
  while (line = client.gets&amp;.chomp) &amp;&amp; !line.empty?
    name, value = line.split(': ', 2)
    headers[name] = value
  end

  body = ''
  if (length = headers['Content-Length']&amp;.to_i) &amp;&amp; length &gt; 0
    body = client.read(length)
  end

  env = {
    'REQUEST_METHOD'    =&gt; method,
    'SCRIPT_NAME'       =&gt; '',
    'PATH_INFO'         =&gt; path,
    'QUERY_STRING'      =&gt; query_string || '',
    'SERVER_NAME'       =&gt; 'localhost',
    'SERVER_PORT'       =&gt; '9292',
    'SERVER_PROTOCOL'   =&gt; http_version || 'HTTP/1.1',
    'rack.version'      =&gt; [1, 3],
    'rack.input'        =&gt; StringIO.new(body),
    'rack.errors'       =&gt; $stderr,
    'rack.multithread'  =&gt; false,
    'rack.multiprocess' =&gt; false,
    'rack.run_once'     =&gt; false,
    'rack.url_scheme'   =&gt; 'http',
  }

  headers.each do |name, value|
    key = case name
          when 'Content-Type'   then 'CONTENT_TYPE'
          when 'Content-Length' then 'CONTENT_LENGTH'
          else "HTTP_#{name.upcase.tr('-', '_')}"
          end
    env[key] = value
  end

  env
end

def send_response(client, status, headers, body)
  phrase = STATUS_PHRASES[status] || 'Unknown'
  client.write("HTTP/1.1 #{status} #{phrase}\r\n")
  headers.each { |name, value| client.write("#{name}: #{value}\r\n") }
  client.write("\r\n")
  body.each { |chunk| client.write(chunk) }
  body.close if body.respond_to?(:close)
end

def run(app, port: 9292)
  server = TCPServer.new('0.0.0.0', port)
  puts "TinyServer listening on http://localhost:#{port}"

  loop do
    client = server.accept

    begin
      env = parse_request(client)

      if env
        status, headers, body = app.call(env)
        send_response(client, status, headers, body)
      end
    rescue =&gt; e
      $stderr.puts "Error handling request: #{e.message}"
      $stderr.puts e.backtrace.first(5).join("\n")

      error_body = "Internal Server Error\n"
      client.write("HTTP/1.1 500 Internal Server Error\r\n")
      client.write("Content-Type: text/plain\r\n")
      client.write("Content-Length: #{error_body.bytesize}\r\n")
      client.write("\r\n")
      client.write(error_body)
    ensure
      client.close
    end
  end
end
</code></pre>
<h2 id="running-it-with-a-real-app"><a class="header" href="#running-it-with-a-real-app">Running It with a Real App</a></h2>
<p>Let's plug in the notes app from the previous chapter:</p>
<pre><code class="language-ruby"># run_notes.rb
require_relative 'tiny_server'
require_relative 'app'  # the NotesApp from the previous chapter

run NotesApp.new, port: 9292
</code></pre>
<pre><code class="language-bash">$ ruby run_notes.rb
TinyServer listening on http://localhost:9292
</code></pre>
<pre><code class="language-bash">$ curl -s http://localhost:9292/notes
[]

$ curl -s -X POST http://localhost:9292/notes \
  -H 'Content-Type: application/json' \
  -d '{"content": "It works"}' | jq .
{"id":1,"content":"It works","created":"2026-02-19T12:00:00+00:00"}

$ curl -s http://localhost:9292/notes | jq .
[{"id":1,"content":"It works","created":"2026-02-19T12:00:00+00:00"}]
</code></pre>
<p>Your handwritten server, running your handwritten app. Real HTTP, real TCP sockets.</p>
<h2 id="making-it-threaded"><a class="header" href="#making-it-threaded">Making It Threaded</a></h2>
<p>The current server handles one request at a time — the next <code>server.accept</code> doesn't run until the current request is finished. For a learning tool, fine. For anything resembling concurrent use, we need threads:</p>
<pre><code class="language-ruby">def run(app, port: 9292)
  server = TCPServer.new('0.0.0.0', port)
  puts "TinyServer (threaded) on http://localhost:#{port}"

  loop do
    client = server.accept

    Thread.new(client) do |conn|
      begin
        env = parse_request(conn)
        if env
          status, headers, body = app.call(env)
          send_response(conn, status, headers, body)
        end
      rescue =&gt; e
        $stderr.puts "Error: #{e.message}"
      ensure
        conn.close
      end
    end
  end
end
</code></pre>
<p>Each connection gets its own thread. The main loop immediately returns to <code>accept</code>, ready for the next connection. This is essentially what WEBrick does (minus SSL, keep-alive, virtual host support, and a decade of edge-case handling).</p>
<h2 id="what-were-not-handling"><a class="header" href="#what-were-not-handling">What We're Not Handling</a></h2>
<p>A production HTTP/1.1 server needs to handle:</p>
<ul>
<li><strong>Keep-alive connections</strong>: HTTP/1.1 keeps connections open by default. Our server closes after every response, which is valid but wasteful.</li>
<li><strong>Chunked transfer encoding</strong>: When <code>Content-Length</code> is unknown at response time, you can send data in chunks.</li>
<li><strong>HTTP pipelining</strong>: Multiple requests on the same connection before any response.</li>
<li><strong>Request timeouts</strong>: A client that connects and never sends data will tie up a thread forever.</li>
<li><strong>Very large bodies</strong>: We read the entire body into memory. For file uploads, you'd want streaming.</li>
<li><strong>SSL/TLS</strong>: Everything above is cleartext.</li>
<li><strong>HTTP/2</strong>: A binary protocol with multiplexing; fundamentally different from HTTP/1.1.</li>
</ul>
<p>Puma, the default Rails server, handles all of these. It's about 10,000 lines of code. Our server is about 80. The gap is instructive — those 9,920 lines are solving real, hard problems. But the core idea — parse a hash, call an object, serialize the result — is in our 80 lines.</p>
<h2 id="the-moment"><a class="header" href="#the-moment">The Moment</a></h2>
<p>Here it is: <strong>the only thing a web server does is build a hash and call your code.</strong> The hash has a few required keys. Your code returns a three-element array. The server turns that array into text and sends it over a socket.</p>
<p>When Puma says it "runs Rack applications," this is what it means. When we say "Rack-compatible server," we mean "a server that knows how to build this specific hash and interpret this specific array." The protocol is simple enough that we just implemented a conforming server in under a hundred lines.</p>
<p>Next: the middleware chain that sits between the server and your app.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rack/first-app.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rack/middleware.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rack/first-app.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rack/middleware.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
