<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Your First Rack App (No Training Wheels) - Rack, Roda, and Ruby</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Rails is just a callable. Sinatra is just a callable. So is Roda. This book strips away the magic of Ruby web development, shows you exactly what Rack is doing under the hood, and teaches you to build from first principles. Know your tools. Really know them.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rack, Roda, and Ruby</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/cloudstreet-dev/Rack-Roda-and-Ruby/edit/main/src/rack/first-app.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="your-first-rack-app-no-training-wheels"><a class="header" href="#your-first-rack-app-no-training-wheels">Your First Rack App (No Training Wheels)</a></h1>
<p>Let's build a Rack application that actually does something. Not a "hello world" one-liner, but a proper small application with routing, multiple responses, and request handling. We'll do it without a framework, using only the <code>rack</code> gem and Ruby's standard library.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<pre><code class="language-bash">mkdir rack-from-scratch
cd rack-from-scratch
bundle init
</code></pre>
<p>Add to your <code>Gemfile</code>:</p>
<pre><code class="language-ruby">gem 'rack'
</code></pre>
<pre><code class="language-bash">bundle install
</code></pre>
<h2 id="the-application"><a class="header" href="#the-application">The Application</a></h2>
<p>We're going to build a small API that manages a list of notes. In-memory storage, no database, no ORM. Just a hash and some Rack.</p>
<pre><code class="language-ruby"># app.rb
require 'json'

class NotesApp
  def initialize
    @notes = {}
    @next_id = 1
  end

  def call(env)
    method = env['REQUEST_METHOD']
    path   = env['PATH_INFO']

    case [method, path]
    when ['GET', '/notes']
      list_notes
    when ['POST', '/notes']
      create_note(env)
    else
      # Match /notes/123
      if (match = path.match(%r{\A/notes/(\d+)\z}))
        id = match[1].to_i
        case method
        when 'GET'    then show_note(id)
        when 'DELETE' then delete_note(id)
        else method_not_allowed
        end
      else
        not_found
      end
    end
  end

  private

  def list_notes
    json_response(200, @notes.values)
  end

  def show_note(id)
    note = @notes[id]
    return not_found unless note
    json_response(200, note)
  end

  def create_note(env)
    body = env['rack.input'].read
    data = JSON.parse(body)

    note = {
      'id'      =&gt; @next_id,
      'content' =&gt; data['content'].to_s,
      'created' =&gt; Time.now.iso8601,
    }

    @notes[@next_id] = note
    @next_id += 1

    json_response(201, note)
  rescue JSON::ParserError
    json_response(400, {'error' =&gt; 'Invalid JSON'})
  end

  def delete_note(id)
    return not_found unless @notes.key?(id)
    @notes.delete(id)
    [204, {}, []]
  end

  def not_found
    json_response(404, {'error' =&gt; 'Not found'})
  end

  def method_not_allowed
    json_response(405, {'error' =&gt; 'Method not allowed'})
  end

  def json_response(status, data)
    body = JSON.generate(data)
    [
      status,
      {
        'Content-Type'   =&gt; 'application/json',
        'Content-Length' =&gt; body.bytesize.to_s,
      },
      [body]
    ]
  end
end
</code></pre>
<pre><code class="language-ruby"># config.ru
require_relative 'app'

run NotesApp.new
</code></pre>
<p>Start it:</p>
<pre><code class="language-bash">$ bundle exec rackup
Puma starting in single mode...
* Puma version: 6.x
* Min threads: 0, max threads: 5
* Listening on http://127.0.0.1:9292
</code></pre>
<h2 id="using-it"><a class="header" href="#using-it">Using It</a></h2>
<pre><code class="language-bash"># Create a note
$ curl -s -X POST http://localhost:9292/notes \
  -H 'Content-Type: application/json' \
  -d '{"content": "Rack is just a contract"}' | jq .
{
  "id": 1,
  "content": "Rack is just a contract",
  "created": "2026-02-19T12:00:00+00:00"
}

# Create another
$ curl -s -X POST http://localhost:9292/notes \
  -H 'Content-Type: application/json' \
  -d '{"content": "env is just a hash"}' | jq .
{
  "id": 2,
  "content": "env is just a hash",
  "created": "2026-02-19T12:00:01+00:00"
}

# List all notes
$ curl -s http://localhost:9292/notes | jq .
[
  {"id": 1, "content": "Rack is just a contract", "created": "..."},
  {"id": 2, "content": "env is just a hash", "created": "..."}
]

# Get one note
$ curl -s http://localhost:9292/notes/1 | jq .
{"id": 1, "content": "Rack is just a contract", "created": "..."}

# Delete a note
$ curl -s -X DELETE http://localhost:9292/notes/1
# 204 No Content, empty body

# Confirm deletion
$ curl -s http://localhost:9292/notes/1 | jq .
{"error": "Not found"}

# Invalid JSON
$ curl -s -X POST http://localhost:9292/notes \
  -H 'Content-Type: application/json' \
  -d 'not json' | jq .
{"error": "Invalid JSON"}
</code></pre>
<p>This is a functional REST API. No framework. No router gem. About 80 lines of Ruby.</p>
<h2 id="what-were-missing"><a class="header" href="#what-were-missing">What We're Missing</a></h2>
<p>This is a good moment to notice what we haven't done:</p>
<p><strong>No request parsing helpers.</strong> We read <code>env['rack.input'].read</code> directly and parsed JSON ourselves. For URL-encoded form data, we'd need to parse <code>name=value&amp;other=thing</code> ourselves, or reach for <code>Rack::Utils.parse_query</code>.</p>
<p><strong>No URL helpers.</strong> We matched routes with a <code>case</code> statement and regex. This works but doesn't scale gracefully.</p>
<p><strong>No content negotiation.</strong> We ignore the client's <code>Accept</code> header. A real API should check whether the client wants JSON before sending JSON.</p>
<p><strong>No error handling for the whole app.</strong> If something explodes with an unexpected exception, Rack's handler returns a 500 with a generic page. We'd want to catch and format that ourselves.</p>
<p><strong>No middleware.</strong> No logging, no session handling, no CORS headers.</p>
<p>These aren't criticisms — they're deliberate omissions to keep the example clear. For production, you'd add them, or use a framework that provides them as defaults.</p>
<h2 id="adding-racks-own-helpers"><a class="header" href="#adding-racks-own-helpers">Adding Rack's Own Helpers</a></h2>
<p>The <code>rack</code> gem includes utilities you can use without a framework. Let's use a couple:</p>
<pre><code class="language-ruby">require 'json'
require 'rack'

class NotesApp
  def call(env)
    request = Rack::Request.new(env)

    method = request.request_method
    path   = request.path_info

    # Parse query parameters automatically
    page = request.params['page']&amp;.to_i || 1

    # Check content type on POST
    if request.post? &amp;&amp; !request.content_type&amp;.include?('application/json')
      return json_response(415, {'error' =&gt; 'Content-Type must be application/json'})
    end

    # ... rest of routing ...
  end
end
</code></pre>
<p><code>Rack::Request</code> wraps the env hash and provides methods like:</p>
<ul>
<li><code>request.get?</code>, <code>request.post?</code>, <code>request.delete?</code></li>
<li><code>request.path_info</code> — same as <code>env['PATH_INFO']</code></li>
<li><code>request.params</code> — merged GET and POST params, URL-decoded</li>
<li><code>request.body.read</code> — the request body</li>
<li><code>request.content_type</code></li>
<li><code>request.cookies</code> — parsed cookie hash</li>
<li><code>request.xhr?</code> — true if it's an XMLHttpRequest</li>
<li><code>request.ip</code> — client IP address</li>
</ul>
<p>And <code>Rack::Response</code> for building responses:</p>
<pre><code class="language-ruby">def json_response(status, data)
  body = JSON.generate(data)
  response = Rack::Response.new
  response.status = status
  response['Content-Type'] = 'application/json'
  response.write(body)
  response.finish  # returns [status, headers, body]
end
</code></pre>
<p>These are thin wrappers around the same env hash and response array. They don't add framework overhead — they add ergonomics.</p>
<h2 id="writing-a-test"><a class="header" href="#writing-a-test">Writing a Test</a></h2>
<p>Because this is plain Ruby, testing is straightforward. You don't need a test server. You just call <code>call</code> with a fake env:</p>
<pre><code class="language-ruby"># test_app.rb
require 'minitest/autorun'
require 'json'
require 'rack/mock'
require_relative 'app'

class TestNotesApp &lt; Minitest::Test
  def setup
    @app = NotesApp.new
  end

  def test_empty_list
    status, headers, body = get('/notes')
    assert_equal 200, status
    assert_equal 'application/json', headers['Content-Type']
    assert_equal [], JSON.parse(body.join)
  end

  def test_create_note
    status, headers, body = post('/notes', '{"content": "test note"}')
    assert_equal 201, status
    data = JSON.parse(body.join)
    assert_equal 'test note', data['content']
    assert data['id']
  end

  def test_show_note
    _, _, body = post('/notes', '{"content": "hello"}')
    id = JSON.parse(body.join)['id']

    status, _, body = get("/notes/#{id}")
    assert_equal 200, status
    assert_equal 'hello', JSON.parse(body.join)['content']
  end

  def test_not_found
    status, _, body = get('/notes/999')
    assert_equal 404, status
    assert_equal 'Not found', JSON.parse(body.join)['error']
  end

  def test_delete_note
    _, _, body = post('/notes', '{"content": "delete me"}')
    id = JSON.parse(body.join)['id']

    status, _, _ = delete("/notes/#{id}")
    assert_equal 204, status

    status, _, _ = get("/notes/#{id}")
    assert_equal 404, status
  end

  private

  def get(path)
    env = Rack::MockRequest.env_for(path, method: 'GET')
    @app.call(env)
  end

  def post(path, body)
    env = Rack::MockRequest.env_for(path,
      method: 'POST',
      input: body,
      'CONTENT_TYPE' =&gt; 'application/json'
    )
    @app.call(env)
  end

  def delete(path)
    env = Rack::MockRequest.env_for(path, method: 'DELETE')
    @app.call(env)
  end
end
</code></pre>
<p><code>Rack::MockRequest.env_for</code> builds a valid Rack env hash for testing purposes. Run it:</p>
<pre><code class="language-bash">$ ruby test_app.rb
Run options: --seed 12345

# Running:

.....

Finished in 0.001s, 4000.0 runs/s.
5 runs, 8 assertions, 0 failures, 0 errors, 0 skips
</code></pre>
<p>Five tests, sub-millisecond runtime, no HTTP server, no magic. The application is a Ruby object. You test it like one.</p>
<h2 id="the-insight"><a class="header" href="#the-insight">The Insight</a></h2>
<p>Here's the moment this chapter promised:</p>
<p><strong>A web application is a function.</strong> It takes input (the env hash) and returns output (status, headers, body). Testing it is exactly as easy as testing any other function. The fact that it handles HTTP is incidental to what it actually is: an object with a <code>call</code> method.</p>
<p>This is why Rack applications are easy to compose, easy to test, and easy to reason about. The framework complexity you're accustomed to isn't inherent to web development — it's a response to problems that arise at scale. At small scale, or with the right tools, you don't always need it.</p>
<p>Next: let's build the thing that calls your app — the server itself.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rack/the-spec.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../rack/server-from-scratch.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rack/the-spec.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../rack/server-from-scratch.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
